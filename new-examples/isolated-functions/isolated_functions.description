// Informal concept: a call to an `isolated` function is concurrency-safe if it is called with arguments
// that are safe at least until the call returns. <br></br>
// A function defined as `isolated`: <br></br>
// - has access to mutable state only through its parameters. <br></br>
// - has unrestricted access to immutable state. <br></br>
// - can only call functions that are `isolated`. <br></br>
// Constraints are enforced at compile-time. `isolated` is a part of the function type.
// Weaker concept than pure function. <br></br>
// Combining `isolated` functions and `lock` allows `isolated` functions to use
// `lock` to access mutable module-level state. <br></br>
// Key concept is `isolated` root. A value `r` is an `isolated` root if mutable state reachable
// from `r` cannot be reached from outside except through `r`. An expression is an
// `isolated` expression if it follows rules that guarantee that its value will be an
// `isolated` root. e.g., <br></br>
// - an expression with a type that is a subtype of `readonly` is always `isolated`. <br></br>
// - an expression `[E1, E2]` is isolated if `E1` and `E2` are `isolated`. <br></br>
// - an expression `f(E1, E2)` is `isolated` if `E1` and `E1` are `isolated`, and
// the type of `f` is an `isolated` function.
